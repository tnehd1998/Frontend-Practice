// 3. 코드에서 나는 악취

// 리펙터링은 숙련된 사람의 직관만큼 정확한 기준은 없다.
// 각자 경험을 통해 감을 키워야 한다.

// 3.1 기이한 이름

// 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지
// 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.

// 3.2 중복 코드

// 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하고,
// 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.

// 3.3 긴 함수

// 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
// 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나옴

// 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.
// 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

// 함수를 짧게 만드는 작업의 99%는 함수 추출하기가 차지한다.

// 3.4 긴 매개변수 목록

// 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면
// 객체 통째로 넘기기를 적용해서 원본 데이터 구조를 그대로 전달한다.

// 3.5 전역 데이터

// 전역 데이터를 방지하기 위해 사용되는 대표적인 리팩터링은 변수 캡슐화하기다.
// 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.

// 3.6 가변 데이터

// 함수형 프로그래밍에서는 데이터가 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에
// 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

// 3.7 뒤엉킨 변경

// 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다.
// 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

// 3.8 산탄총 수술

// 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생함
// 어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩터링으로
// 하나로 합치는 것도 산탄총 수술에 대체하기 좋은 방법이다.

// 3.9 기능 편애

// 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와
// 상호작용할 일이 더 많을 때 발생함
// 해결 방안으로 이 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜럿이 드러나므로
// 소원대로 데이터 근처로 옮겨주면 된다.

// 3.10 데이터 뭉치

// 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 상황
// 데이터 뭉치인지 판별하려면 값 하나를 삭제해보자.
// 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

// 3.11 기본형 집착

// 기본형을 객체로 바꾸기를 적용하면 기본형만이 거주하는 구식 코드를 의미있는
// 자료형이 사는 최신식 코드로 탈바꿈 시킬수 있다.

// 3.12 반복되는 switch문

// 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다
// 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.

// 3.13 반복문

// 일급 함수를 사용해 반복문을 대체 할 수 있기 때문에 더이상 사용되지 않는다.

// 3.14 성의 없는 요소

// 필요 없는 메서드나 클래스는 과감하게 지워주는 작업을 해야한다.

// 3.15 추측성 일반화

// 나중에 필요할꺼야라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직과
// 같은 걸리적거리는 코드는 눈앞에서 바로 지워버린다.
// 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에 죽은 코드 제거하기로 날려버린다.

// 3.16 임시 필드

// 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
// 클래스를 추출하거나, 함수를 옮겨 모조리 새 클래스에 몰아넣거나 유효하지 않으면 대안 클래스를 만들어
// 제거한다.

// 3.17 메세지 체인

// 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 의미함
// 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 함

// 3.18 중개자

// 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면, 중개자 제거하기를
// 활용하여 실제로 일을 하는 객체와 직접 소통한다.
// 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자.

// 3.19 내부자 거래

// 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.

// 3.20 거대한 클래스

// 클래스 추출하기로 필드들 일부를 따로 묶는다.
// 그 클래스 안에서 자체적으로 중복을 제거하는 것

// 3.21 서로 다른 인터페이스의 대안 클래스들

// 클래스를 사용할 때의 큰 장점은 인터페이스가 같으면 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것

// 3.22 데이터 클래스

// 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.

// 3.23 상속 포기

// 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용해서 아예 상속 메커니즘에서 벗어나자

// 3.24 주석

// 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
