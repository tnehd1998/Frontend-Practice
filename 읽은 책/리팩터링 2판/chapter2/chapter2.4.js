// 2.4 언제 리팩터링해야 할까?

// 3의 원칙
// 1. 처음에는 그냥 한다.
// 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
// 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

// ✅ 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

// 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.
// 이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질만한 부분을 찾는다.

// 함수 매개변수화하기를 적용하여 그 함수에 필요한 매개변수를 지정해서 호출하기만 한다.

// 버그를 잡을 때도 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면,
// 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.

// 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에,
// 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.

// ✅ 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

// 코드를 수정하려면 먼저 그 코드가 하는 일을 정확히 파악해야 한다.

// 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.

// 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

// ✅ 쓰레기 줍기 리팩터링

// 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음,
// 하던 일을 끝내고 나서 처리한다.
// 이것이 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.

// 물론 수정하려면 몇 시간이나 걸리고 당장은 더 급한 일이 있을 수 있다.
// 그렇더라도 조금이나마 개선해두는 것이 좋다.

// 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.

// ✅ 계획된 리팩터링과 수시로 하는 리팩터링

// 리팩터링 시간을 일정에 따로 잡아두지 않고, 대부분의 리팩터링을 다른 일을 하는 중에 처리한다.

// 📌 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

// 📌 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 그런 다음 쉽게 수정하자.

// 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다.
// 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.

// 리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 여러분의 팀에 적합한 방식을
// 실험을 통해 찾아내야 한다.

// ✅ 오래 걸리는 리팩터링

// 대규모 리팩터링의 경우 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수도 있다.

// 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다.
// 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다.

// ✅ 코드 리뷰에 리팩터링 활용하기

// 코드 리뷰의 장점
// 1) 개발팀 전체에 지식을 전파하는 데 좋다.
// 2) 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.
// 3) 깔끔한 코드를 작성하는 데에도 도움이 된다.
// 4) 다른 사람의 아이디어를 얻을 수 있다.

// 경험한 가장 좋은 방법은 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것
// 즉 짝 프로그래밍을 하는 것이 제일 좋다는 의견

// ✅ 관리자에게는 뭐라고 말해야 할까?

// 관리자가 기술에 정통하고 설계 지구력 가설도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설득할 수 있다.

// 기술을 모르는 상당수의 관리자와 고객은 코드베이스의 건강 상태가 생산성에 미치는 영향을 모른다.
// 이런 상황에 있는 이들에게는 "리팩터링한다고 말하지 말라"고 조언한다.

// 리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다.

// ✅ 리팩터링하지 말아야 할 때

// 지저분한 코드라도 굳이 수정을 할 필요가 없다면 리팩터링하지 않는다.

// 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.
