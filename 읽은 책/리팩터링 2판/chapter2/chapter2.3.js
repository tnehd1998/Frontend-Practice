// 2.3 리팩터링하는 이유

// 리팩터링이 소프트웨어의 모든 문제를 해결해주지는 않는다.
// 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.

// 📌 리팩터링하면 소프트웨어 설계가 좋아진다.

// 리팩터링을 하지 않으면 소프트웨어의 내부 설계(아키텍처)기 썩기 쉽다.
// 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
// 코드만 봐서 설계를 파악하기 힘들어진다.

// 규칙적인 리팩터링은 코드의 구조를 지탱해준다.

// 중복 코드 제거는 설계 새선 작업의 중요한 한 축을 차지한다.
// 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며,
// 이는 바람직한 설계의 핵심이다.

// 📌 리팩터링하면 소프트웨어를 이해햐기 쉬워진다

// 프로그래밍은 내가 원하는 바를 정확히 표현해 컴퓨터에게 시키는 작업이다.
// 소스 코드는 해당 코드를 읽고 해석하는 사람을 우선으로 생각해서 짜야한다.

// 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다.
// 코드의 목적이 더 잘 드러나게 리팩터링하여, 내 의도를 더 명확하게 전달하도록 개선해야 한다.

// 📌 리팩터링하면 버그를 쉽게 찾을 수 있다

// 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.
// 프로그램의 구조를 명확하게 다듬으면 그냥 "이럴 것이다"라는 가정하던 점들이 분명하게 드러나는데,
// 버그를 지나칠 수 없을 정도까지 명확해진다.

// 📌 리팩터링하면 프로그래밍 속도를 높일 수 있다

// 리팩터링을 하면 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점이 결국 품질 향상에 직결된다.
// 하지만, 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어진다는 오해를 하곤한다.

// 한 시스템을 오래 개발하다 보면 초기에는 기능추가의 진척이 빨랐지만,
// 현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다.
// 새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어나게 된다.

// 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
// 모듈화가 잘되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.
// 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

// 지구력 가설 : 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서
// 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.
