// 11.1 많은 데이터 렌더링하기
// 많은 데이터를 넣는 순간 해당 프로그램 속도가 확연히 느려지는게 보임

// 11.2 크롬 개발자 도구를 통한 성능 모니터링
// 크롬의 개발자 도구 중 Performance를 사용하여 특정 기능이 사용하는데 몇초가 걸리는지 측정
// 2500개의 데이터밖에 없는데도 작업을 처리하는데 1.02초가 걸리는 매우 느린 프로그램임을 확인

// 11.3 느려지는 원인 분석
// 컴포넌트가 리렌더링되는 상황
// 1. 자신이 전달받은 props가 변경될 때
// 2. 자신의 state가 바뀔 때
// 3. 부모 컴포넌트가 리렌더링될 때
// 4. forceUpdate 함수가 실행될 때

// 제작한 프로그램의 경우 특정 항목을 체크한 경우 App 컴포넌트의 state가 변경되면서
// App이 리렌더링 되기 때문에 해당 컴포넌트에 소속되어 있는 무수한 자식 컴포넌트들도
// 모두 리렌더링되면서 해당 프로그램의 속도가 매우 느려짐

// 11.4 React.memo를 사용하여 컴포넌트 성능 최적화
// shouldComponentUpdate 라이프사이클과 같은 기능을 하는 React.memo함수를 사용하여
// 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정해 성능을 최적화함

// 11.5 onToggle, onRemove 함수가 바뀌지 않게 하기
// 해당 프로젝트에서 todos 배열이 업데이트되면 onRemove와 onToggle 함수도 새롭게 바뀌지 때문에
// 최신 상태의 todos를 참조하기 때문에 todos 배열이 바뀔때마다 함수가 새로 만들어짐

// 11.5.1 useState의 함수형 업데이트
// 특정 내용 업데이트 시 새로운 내용을 넣는것이 아니라 기존의 내용이 어떻게 변하는지 알려주는 방식으로 변경

// 11.5.2 useReducer 사용하기
// redux처럼 useReducer를 사용하여 상태관리가 가능함

// 11.6 불변성의 중요성
// 리액트 컴포넌트에서 상태를 업데이트할 때 불변성을 지키는 것은 매우 중요함
// 불변성이 지켜지지 않으면 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못함 => React.memo 작동하지 않음
// 복잡한 경우 immer라이브러리를 사용하면 편하게 작업 가능

// 11.8 react-virtualized를 사용한 렌더링 최적화
// 스크롤 하기 전에 보이지 않는 데이터들을 미리 가져오는 비효율적인 프로그램 작업이 진행됨
// 스크롤 하기 전에 보이는 데이터는 9개인데 보이지 않는 데이터 2491개도 같이 가져오는 시스템 자원 낭비임

// react-virtualized 라이브러리를 사용하여 낭비되는 자원을 쉽게 아낄 수 있음
// 페이스북의 스크롤이 맨 아래일 때, 필요한 정보를 더 불러오는 기능과 같음
