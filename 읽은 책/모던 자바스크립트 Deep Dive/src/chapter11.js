// Chapter 11) 원시 값과 객체의 비교

// 1) 원시 타입과 객체 타입이 다른 3가지 측면

// - 원시 값은 변경 불가능, 객체는 변경 가능한 값

// - 원시 값을 변수에 할당하면 변수만큼의 공간이 실제 값이 저장,
// 객체를 변수에 할당하면 변수에는 참조 값이 저장

// - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어
// 전달 됨, 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이
// 복사되어 전달 됨

// 2) 원시 값 : 변경 불가능한 값, 읽기 전용 값으로서 변경이 불가능함
// 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술임

// 문자열과 불변성 : 문자열은 변경 불가능한 값이기 때문에 한번 생성된
// 문자열은 읽기 전용 값으로서 변경할 수 없다.
let str = "Hello";
str[0] = "S";
console.log(str); // "Hello"

// 값에 의한 전달 : 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는
// 할당되는 변수의 원시 값이 복사되어 전달 됨
let score = 80;
let copy = score;
console.log(score, copy); // 80 80
console.log(score === copy); // true
score = 100;
console.log(score, copy); // 100 80
console.log(score === copy); // false
// score, copy는 다른 메모리 공간에 저장된 별개의 값임

// "값에 의한 전달"도 사실은 값을 전달하는 것이 아니라 정확하게는
// 메모리 주소를 전달하는 개념이며 전달된 메모리 주소를 통해 메모리 공간에
// 접근을 해 값을 참조하는 원리임

// 3) 객체 : 프로퍼티 개수가 정해져 있지 않아 원시 값과 같이 확보해야 할
// 메모리 공간의 크기를 사전에 정해 둘 수 없음

// 객체는 변경 가능한 값임
var person = {
  name: "Lee",
};
console.log(person);

// 객체를 할당한 변수의 경우 변수는 객체를 참조하거나 가리키고 있다고 표현

person.name = "Kim";
person.address = "Seoul";
console.log(person); // {name: "Kim", address: "Seoul"}

// 객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이며,
// 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는
// 변경 가능한 값으로 설계되어 있다. 메모리 사용의 효율성과 성능을 위해
// 어느 정도의 구조적인 단점을 감안한 설계이지만, 원시 값과는 다르게
// 여러 개의 식별자가 하나의 객체를 공유하는 상황이 발생한다.

// 얕은 복사 : 특정 객체의 프로퍼티 값을 공유하여 사용
// 깊은 복사 : 특정 객체의 프로퍼티 값을 다른 공간에 다시 할당하여 사용

// 참조에 의한 전달 : 원본의 참조 값이 복사되어 다른 변수에 전달되는 것
// 두개의 식별자가 하나의 객체를 공유
var me = {
  name: "Lee",
};
var copyMe = me;
console.log(me === copyMe); // true
copyMe.name = "Kim";
me.address = "Seoul";
console.log(me); // {name: "Kim", address: "Seoul"}
console.log(copyMe); // {name: "Kim", address: "Seoul"}

// 결국 "값에 의한 전달"과 "참조에 의한 전달"은 식별자가 기억하는 메모리
// 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.
// 자바스크립트에서는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만
// 존재한다고 말할수 있다.
// 이러한 용어를 사용하지 않고 "공유에 의한 전달"이라고 표현하는 경우도 있음
