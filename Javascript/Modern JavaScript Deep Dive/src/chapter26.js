// Chapter 26) ES6 함수의 추가 기능

// 1) 함수의 구분
// ES6 이전의 모든 함수는 일반함수로서 호출할 수 있는 것은 물론 생성자
// 함수로서 호출할 수 있다, 즉 ES6 이전의 모든 함수는 callable이면서
// constructor이다

// 일반함수는 constructor이지만 ES6의 메서드와 화살표 함수는
// non-constructor다

// 2) 메서드
// ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다
// 메서드를 정의할 때 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전의
// 방식은 사용하지 않는 것이 좋다

// 3) 화살표 함수

// ✅ 화살표 함수 정의
// 화살표 함수도 일급 객체이므로 map, filter, reduce같은 고차 함수에
// 인수로 전달할 수 있고, 이 경우 일반적인 함수 표현식보다 표현이
// 간결해지고 가독성이 좋다

// ✅ 화살표 함수와 일반 함수의 차이
// 1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructorek
// 2. 중복된 매개변수 이름을 선언할 수 없다
// 3. 화살표 함수는 함수 자체의 this, argument, super, new.target
// 바인딩을 갖지 않는다

// ✅ this
// 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수
// 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.
// 이를 lexical this라 한다

// - 화살표 함수로 메서드를 정의하는 것은 바람직하지 않다.
// - 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 ES6 메서드를
// 사용하는 것이 좋다

// ✅ super
// 화살표 함수는 함수 자체의 super 바인딩을 갖지 않기 때문에 참조를 하게되면
// this와 마찬가지로 상위 스코프의 super를 참조함

// ✅ arguments
// 화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않기 때문에 참조를
// 하게되면 상위 스코프의 arguments를 참조함

// 4) Rest 파라미터

// ✅ 기본 문법
// Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다

function foo(...rest) {
  console.log(rest); // [1, 2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5);

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest); // [3, 4, 5]
}

bar(1, 2, 3, 4, 5);

// - 일반 매개변수와 Rest 파라미터는 함께 사용할수 있지만 반드시 마지막
// 파라미터이어야 한다
// - Rest 파라미터는 단 하나만 선언 할 수 있다
// - 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않음

// ✅ Rest 파라미터와 arguments 객체
// - 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 arguments
// 객체를 활용하여 인수를 받았는데, 이후 arguments 객체를 배열로 반환해야
// 하는 번거로움이 존재했었다
// - ES6에서는 rest 파라미터를 사용하여 번거로움을 피할 수 있다
// - 화살표 함수는 함수 자체의 arguments 객체를 갖지 않기 때문에 화살표
// 함수로 가변 인자 함수를 구현해야 할 때는 반드시 rest 파라미터를 사용해야
// 한다

// 5) 매개변수 기본값
// 매개변수에 기본값을 할당하여 undefined로 방치되는 상황을 방지한다

function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1)); // 1

// Rest 파라미터에는 기본값을 지정할 수 없다
